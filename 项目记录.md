2020年7月17日


蚂蚁一期记录：
	不能把2W条数据放进list，分页查询数据库，小的集合装，分段发生

	this是new出来的时候用，static代表类名.class。

	死锁通俗的解释	https://blog.csdn.net/weixin_43145361/article/details/93035355

	三次握手：客户端发送一个随机码给服务端，服务端收到那个随机码，随机码+1和另一个随机码返回给客户端。
	客户端收到后，把第二个随机码+1，返回给服务端。这时候两边进入监听状态。

	反向代理和正向代理区别。反向代理在服务器的前面代理，正向代理服务器在前面。具体看文档。

==================================================

Java校招面试 Google面试官亲授
	线程和进程的区别：
		进程之间不共享内存，但文件、网络资源是所有进程共有的

		线程调用堆栈，就是调用栈，放函数的参数、返回地址、局部变量，PC放下一条执行指令的地址

		进程之间可以通过tcp/ip实现交互。

	寻址过程：
		指针访问逻辑内存，逻辑内存去对应实际内存，实际内存如果不够，就要去硬盘开辟虚拟内存，虚拟内存
		通过分页找物理内存，最后把物理内存里P指针所在的数据取出来放进寄存器。

	网络：
		wireshark工具

==========================
	关于java算法的策略：
		把《剑指offer》、《经典》、本地的那二套过一遍就可以了

	action();

	private static void action(){
		System.out.println(666);
	}
	方法加了static才能直接使用。

	Stack<Integer> stack = new Stack<Integer>();
	两边最后都要加类型


	负数在java中用补码表示
	//-8的补码
	//原码 			1000 0000 0000 0000 0000 0000 0000 1000
	//符号位不变，取反 1111 1111 1111 1111 1111 1111 1111 0111
	//加1 			1111 1111 1111 1111 1111 1111 1111 1000

	补码求十进制数	 	1111 1111 1111 1111 1111 1111 1111 0000	
	//-1 		 	1111 1111 1111 1111 1111 1111 1110 1111
	//符号位不变，取反 1000 0000 0000 0000 0000 0000 0001 0000
	//-16

==========================================

	类如果不写无参构造方法，类会自带。可以直接new。


	java中&&的短路功能，当第一个表达式的值为false的时候，则不再计算第二个表达式；&则两个表达式都执行。


	二叉查找树：
		左边<中间<右边


	取平均数，如果是偶数个取偏左边那个
	(start + end) >> 1;


	树的深度：
		一颗树只有一个节点,它的深度是1。有左子树，二叉树的深度应该是其左子树的深度加1。


	ArrayList和LinkedList的大致区别如下:
		1.ArrayList是数组，LinkedList是链表。
		2.get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针。
		3.add和remove，LinkedList比较占优势，因为ArrayList要移动数据。

	https://blog.csdn.net/tttzzztttzzz/article/details/84916281

==========================================

## 多行注释，注释在变量和方法上
	/**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

## 满二叉树：
	满的二叉树

## 各种二叉树：
	https://blog.csdn.net/sinat_41144773/article/details/89530403

## HashMap源码分析：
	
- HashMap k可以为空，Null当成一个key来存储

- 什么是hash：

	- 把任意长度的输入，通过哈希算法，转换成固定长度的输出，所输出的称为哈希值

	- 具体说就是：

		- 把一串数据分成固定长度，比如128块，每一块进行hash运算（关于hash运算有多种算法，比如使用MD5算法）。

		- 每一块进行迭代（如前一块的hash值与后一块的hash值进行异或）。

		- 如果不够128位，则用0或1进行补。

		- 得到的结果，作为这段数据的特征（指纹）。

	hash冲突：

		- 对应不同的关键字可能获得相同的hash地址。

	- 参考：https://www.zhihu.com/question/26762707

- 什么是map:
	
	- 地图x、y存储

- HashMap基本原理：

	- 把x通过hash出来的值，通过值定位到这个map，然后value存储到这个map中

 

- 关键代码：(h = key.hashCode()) ^ (h >>> 16)

	- 由于某种原因始终是hashcode的低16位（甚至更低）参与运算。要是高16位也参与运算，会让得到的下标更加散列。

	- 所以让他的hashCode()和自己的高16位进行^运算。

	- 参考：https://blog.csdn.net/qq_42034205/article/details/90384772

- 参考：https://juejin.im/post/6844904164942692360

==========================================

## 高性能必学之Mysql主从架构实践
	
- 怎么看数据哪个节点查的，看日志

- /*Master*/select * from myTable; 会强制查主库

========================================

- //前面写接口，定义参数类型。后面子类实现参数就不用写参数了。
List<Element> preEles = new ArrayList<>(); //

## 私塾架构

- 怎么建工程、合并工程

- parent工程->maven install->底下的各个工程会生成war包

- 除了parent都是打成war包，

- 要使用common里的东西，就要把pom.xml添加上common依赖

- session是在web服务器的内存，分布式系统首先不考虑用session

- 实体类映射数据表，实体名称保持和数据表字段一模一样。Integer--int、String--varchar。hashcode用uuid就够了

- CustomerDao.java是接口，CustomerMapper.xml是实现

- mybatis的精髓在与能在xml中写sql语句

- xml中的id要和方法名一样

- mybatis #代表占位符

- MybatisConf.xml
	
	- <!-- 定义别名 -->
		<typeAliases>

	- 分页插件，拦截sql、dialect配数据库类型

- ctx.getBean("client");默认小写

- getByConditionPage，后面加Page自动被分页插件过滤


- logback.xml，debug="false"关闭调试

- @Transactional注解，代理对象的问题，不代理属性，代理方法getS()，拦截。12节。

- 逻辑层、数据层排除Controller包，配在applicationContext.xml里。控制层配在spring-mvc.xml里主要
就是对Controller包扫描。

- spring-mvc.xml还配了静态处理、视图解析器

- applicationContext.xml、spring-mvc.xml都配在web.xml里面

- 参数前面加@ModelAttribute("cm")，把参数绑定到某个域中，下个页面取出来

- @RequestMapping(value="toUpdate/{customerUuid}"，走restful风格提交参数

- @PathVariable占位符映射，获取到浏览器请求参数，https://blog.csdn.net/sswqzx/article/details/84194979

- 参数前面加@RequestParam("uuid")，接单个对象

- 有两种查询方法，一种表达提交、一种绑定button动作

- jquery，$("#pwd")，#代表取id

- super.setEleName加了super就是调用父类的方法，不加就调用本类



- X-gen设计模式综合实战1——整体介绍 https://www.jianshu.com/p/afa8fb49d424

=========================

## idea快捷键

- 在记事本里
- commond+alt+l 格式化快捷键
- alt+enter 移包快捷键
- alt+enter 补全引用
- cmd+\` 切换窗口

## 面向对象

- 多态：父类的引用指向子类对象

- 类的内部执行顺序，先跑父类构造方法，再跑成员变量，再跑自己的  构造方法

- 子类的无参构造方法被调用，父类的无参构造方法也会被调用

## 线程

- volidate 轻量级的synchronize，用volidate修饰变量，发生修改立即更新到主存

## map的keys转list

- for (String s : moduleConf.getMapNeedGenTypes().keySet()) {
        listNeedGenTypes.add(s);
	}

## maven

- 天龙->maven文件夹。

- maven工程默认是war

- 多模块工程，父工程是pom，子模块是war，子模块加入到父模块的modules中，可以互相调用

- 手动安装jar包命令 mvn install:install-file -Dfile="/Users/chen/Downloads/java_memcached-release_2.6.6/java_memcached-release_2.6.6.jar" -DgroupId=com.danga -DartifactId=java-memcached -Dversion="2.6.6" -Dpackaging=jar

- 部署过程：子工程maven-clean、子工程maven-install、总工程maven-install
	得到war包、解压、压缩成zip包、上传到tomcat的webapps、unzip

- 打war包。1.pom.xml加个插件 2.改成war 3.进入项目目录，mvn clean package

- dubbo 2.8.4问题 https://blog.csdn.net/m0_38138387/article/details/79465795
==========================

# 设计模式综合

- 进去GenFacade的generate()方法，外观模式

	- 进去CoreMediator的getInstance()，中介者

	- 进去CoreMediator的getDefaultGenConfProvider()，中介者获取某个配置

	- 进去GenConfXmlImpl的构造方法GenConfXmlImpl()，这个类对应GenConf.xml

- 进去GenFacade的generate(GenConfImplementor providrer)方法

	- 进去CoreMediator的getNeedGenModuleConf(GenConfImplementor providrer)，中介者获取某个配置

		- 进入 GenConfFactory的createGenConfEbi(GenConfImplementor provider)，简单工厂

			- 进入 GenConfEbo的getInstance()方法 懒汉单例

				- 进入 GenConfEbo的GenConfEbo(GenConfImplementor provider)方法 

		- 进入 GenConfEbo的getMapModuleConf()

			- 进入 ConfManager的getInstance(GenConfImplementor provider) 单例
			获取配置数据，每个配置数据对应一个实例

				- 进入ConfManager的ConfManager(GenConfImplementor provider)方法

					- 进入readConf(GenConfImplementor provider)

						- 进入 readGenConf(GenConfImplementor provider) 

							- 进入 GenConfXmlImpl的getNeedGens()方法

								- 进入 GenConfXmlImpl的readNeedGends()方法

									- 进入GenConfXmlImpl的getContext()方法

										- 进入GenConfBuilder的GenConfBuilder()方法

										- 进入GenConfBuilder的addxmlFilePre()方法

										- 进入GenConfBuilder的getBuilderBuffer()

											- 进入ExpressionEnum的getExpr()方法

										- 进入GenConfBuilder的getBuilderBuffer()方法

										- 进入GenConfBuilder的addGenConf()方法

										- append(GenConfEnum.GenConf) 拼接
										cn/javass/xgenconfxml/GenConf
										cn/javass/xgenconfxml/GenConf.xml

										- 进入GenConfBuilder的build()方法

										- 进入Context的getInstance(String fiePathName)方法

										- 进入Context的Context(Document document)方法

										- 进入Context的init()方法

								- 进入GenConfXmlImpl的parseNeedGenIds(Context c)方法

									- 进入GenConfBuilder拼接 GenConf/NeedGens/NeedGen$.id

									- 进入Parser

										-进入ParseCaretaker的retriveMemento()方法 备忘录

										- mapPath2Expression(mapPath)解析 GenConf/NeedGens/NeedGen$.id 对应GenConf.xml

										- buildTree(notParseExpr,prefixRe,mapPathAndRe,mapRe) 语法树 对应GenConf.xml 返回ElementExpression类型

										- saveMemento(new MementoImpl(mapRe)) 备忘录

								- 进入Context的interpret()方法，这里的Context存了一个map里面也存了一个Context，有点链表的意思，对应GenConf.xml

								- 返回List<NeedGenModel>，对应GenConf.xml的NeedGen

							- 同理进入 GenConfXmlImpl的
							setMapConstants(provider.getMapContents());
							setThemes(provider.getTheme());

							- 进入confManager的readOneModuleGenConf(NeedGenModel ngm)方法

								- 关键代码this.genCof.getThemeById(ngm.getTheme()).getMapProviders().get(ngm.getProvider()); 从GenConf.xml的<Theme id="simple">取
								ThemeConf.xml的<Providers>下面的<Provider id="XmlModuleGenConf">

								- ModuleConfModel对应UserGenConf.xml

								- setUseTheme 主题是simple

	- 进入GenFacade类的genOneModule(ModuleConfModel mcm)方法 命令模式，分发类不负责具体实现

		- 进入DefaultCommand的excute()方法，责任链模式

			- needProxyGen(String needGenType, ModuleConfModel moduleConf) 代理

				-进入GenInvocationFactory的createGenInvocation(String needGenType, ModuleConfModel moduleConf)

				- DefaultGenInvocation类 executeGen()方法，状态模式

				- obj = ((BaseGenAction) Class.forName(className).newInstance()).generate(ctx.getModuleConf());模板方法

================================

# javaweb

- 模型类要序列化

- 参数前面加@RequestParam("……") 接表单的参数

# Nginx

- 安装，源码，make && make install

- 动静分离：jsp走Tomcat，静态资源Ngnix自己去读文件。提升Tomcat性能，减少并发访问压力。

- 正向代理，client和Proxy是一起的，访问服务器。反向代理，Proxy和服务器是一起的，被客户端访问。

==================

腾讯蚂蚁教育

##jvm

- 性能优化一般优化堆

- 垃圾回收，刚new出来的对象放在新生代，使用次数多了，移到老年代

- 一般工作中配内存，初始值和最大值相同，接近电脑内存配置

- java内存结构最核心4个，方法区、堆、栈、本地方法栈

- 引用计数算法，给对象加一个引用计数器，开始定一个值15，引用一次就+1，失效一次-1。计数器为0时，回收内存。缺点，父对象有个子对象的引用，子对象反过来引用父对象，这样就形成循环引用，计数器永不为0。

## 外网映射

- ngrok
- 花5块钱，NatApp外网映射

## 操作系统

- 什么是进程：正在运行的程序

- 什么是线程：进程的一条执行路径

- 什么是多线程：就是为了提高程序的效率

- 主线程死掉，gc线程也跟着死掉，这就叫守护线程。迅雷退出，把线程设为守护线程，可以继续下载。

- Vector是线程安全的，方法上加了synchronized锁。ArrayList是线程不安全的，方法没有加任何锁。

===========================

##web安全

- xss攻击获取他人cookie。某网站，有个搜索框，输入一段js脚本，获取当前浏览器的所有cookie，并且保存到服务器某个文件里。只要访问这个文件，就能拿到这些cookie。把这段js链接发给其他人，一点击，就能获取到其他人的cookie。

## orm框架实现

- 建表

## storm

- tar、mv、vi /etc/profile && source、public文件夹（提供ui组件）

- cd conf && vi storm.yml

- 配zookeeper.servers，注意三个节点 
	192.168.1.114
	192.168.1.115
	192.168.1.116

- numbus.host 配主节点、dir、port、supervisors port 监管人，一主二从，一个从节点二个端口

- 三个节点先启动zookeeper zkserver.sh start

- 主节点启动 storm nimbus & 后台启动
  从节点启动 storm supervisors & 后台启动

- jps查看是否启动

- 看日志 tail -f -n 100 nimbus.log

- storm ui &	，	cat ui.log

=========================

##企业级keepalived高可用实战与Nginx负载均衡视频教程

- 网站问题：大访问量、大存储量、大数据量

- 负载均衡：多台服务器给外界提供响应，轮询

- 集群：只有一台服务器激活给用户提供响应，其他服务器休眠

=============

深入理解热门开源项目Guns管理系统
##springboot

- 起步依赖本质是一个maven的pom，定义了对其他库的传递依赖 

==============================

亿级流量电商详情页系统实战
##缓存系统

- 商品详情页的页面静态化架构、缺陷

- 04_大型电商网站的异步多级缓存构建+nginx数据本地化动态渲染的架构
	
	- 服务器，前端系统访问Nginx，Nginx系统提供html模板+本地缓存数据，返回给前端
	- 如果Nginx没有数据，到redis取
	- redis数据从缓存数据生产服务里面来
	- 缓存数据生产服务从MQ里面来
	- MQ从微服务里面取数据
	- 微服务从mysql里面取数据

- 搭建
	- 建4个虚拟机
	- 配网络，主机默认网关 192.168.31.1
	- vi eth0、改成static、ipadd就用默认的192.168.31.187、等等其他
	- server network restart、ping宿主机
	- 关闭防火墙 service iptables stop、service ip6tables stop、chkconfig iptables off、chkconfig ip6tables off
	- 装java、perl
	- 配hostname、hosts映射关系、配秘钥
	- 装redis。通过自动化脚本进行启动。以daemon进程运行。

- redis持久化的意义
	- 意义：故障恢复
	- 怎么做持久化：redis数据放到磁盘上，磁盘数据备份一份到阿里云上。恢复的时候，拷到另一台机器的磁盘，redis启动的时候，自动从磁盘加载数据到内存。

- 两种持久化的原理
	- RDB原理
		- 隔几分钟备份一次
	- AOF原理
		- redis规定了内存只能存放1G的数据
		- 不断的写写写，AOF里面有了100w数据相关的写指令日志
		- LRU清除算法。50w数据被清掉了，又写了50w数据到AOF，一共150w
		- 搞个新的AOF，基于redis当前最新的100w数据

- 两种持久化的对比
	- RDB的优点
		- 定时生成全量快照文件，进行持久化，适合做冷备份
		- 让redis保持高性能
	- RDB的缺点
		- 丢数据会比较多
	- AOF的优点
		- AOF可以更好的保护数据不丢失
	- AOF缺点
	- RDB实验一、实验二 
		- 相关命令 redis-cli、set k4 v4、set k6 v6、exit、ps -ef | grep redis
		kill -9 32268、cat dump.rdb、cd /var/run && rm -rf redis_6379.pid、
		cd /etc/init.d/ && ./redis_6379 start

	- 跑脚本之前，chmod 777 redis_rdb_copy_daily.sh

- 承载读请求QPS超过10万
	- 如果写多读少，做异步，不是做缓存了

- 在项目中部署redis的读写分离架构
	- 安装redis时需要的组件,redis-3.2.8.tar.gz和tcl8.6.1-src.tar.gz

- 23.哨兵原理
	- quorum数量的哨兵，认为odown，选举一个哨兵。再得到majority数量哨兵的授权，即把slave切换成master。
	- 如果quorum>majority，quorum哨兵授权，就可以切换了。

- 24.3节点方式部署哨兵集群
	- 新建个配置文件 /etc/sentinel/5000.conf

- 28_在项目中重新搭建一套读写分离+高可用+多master的redis cluster集群
	- 每台机器放两个7001、7002

34_redis阶段性总结：1T以上海量数据+10万以上QPS高并发+99.99%高可用

- 39_库存服务的开发框架整合与搭建：spring boot+mybatis+jedis
	- maven工程，看看

- 47_完成spring boot整合ehcache的搭建以支持服务本地堆缓存
	- @EnableCaching注解 如果你使用了这个注解，那么你就不需要在XML文件中配置cache manager了。

- 121_支撑高并发与高可用的大型电商详情页系统的缓存架构课程总结

==================================

## 精通并发与Netty

- 2
	- WebSocket长连接，不需要传header，只需要body
- 4
	- gradle、配环境变量

- 三次握手 https://juejin.im/post/6844903957127495687

- 5
	- 远程调用、长连接、http，
	- 请求->channal->方法
	- ServerBootstrap轻松启动服务器
	- 每个netty程序的流程：定义循环组->通道处理器->回调方法调用

- 6
	- favion.ioc网站图标    
	- curl 'http://loclahost:8899'    
	- lsof -i:8899
- 7
	- netty能作为HTTP服务器、Socket编程
- 8
	- 目标：客户端上线，通知服务端，服务端再向每个客户端发送通知
- 9
	- 长连接检测技术，心跳：集群，主写，异步方式同步到从节点。数据不是实时一致性的，最终一致性。节点间确认对方是否活着，发送心跳包。
- 10
	- HTTP是应用层，TCP是传输层
	- HTTP：无状态，借助session、cookie；请求响应；包含header、body
	- 短连接、长连接区别

- 12 ptotobuf
	- 序列化反序列化，也叫编码、解码
	- rmi:remote method invocation，只针对java
	- RPC:remote procedure call 远程过程调用，跨语言

- 15 Protobuf集成Netty与多协议消息传递
	- 客户端调用构造对象，发送，服务器端直接接收到了	

- 16 
	- 用枚举来解决不同message传到服务器

	- 问题：怎么共享protobuf生成出来的文件

- 17 解决16的问题
	- Protobuf-Java : git仓库里面的仓库
	- 用git submodule技术将protobuf生成出来的文件推送到Protobuf-Java里面。将Protobuf-Java引入到ServerProject和ClientProject。
	- git subtree方案
	- git test环境和master环境保持一致
	- homebrew的使用

- 18 Apache Thrift
	- 跨语言

- 32 	IO
	- 数据从外面流入程序，输入流；从程序流到外面，输出流
	- io读取逻辑
		- 打开一个流
		- while循环，不断读取流中的数据
		- 关闭流

		- 打开一个流
		- while循环，不断往外写数据
		- 关闭流
	- volatile关键字
		- 每个线程有自己的工作内存，加了volatile关键字，修改工作内存后会同步到主内存。
		- 指令重排序

- 33 Java NIO深入详解与体系分析
	- 1）Java.io中最为核心的一个概念是流（stream），面向流的编程。流是信息的载体。Java中一个流要么是输入流，要么是输出流，不可能同时既是输入流又是输出流。

	- 2）Java.nio中拥有3个核心概念：selector，channel，buffer。在java.nio中是面向块（block）或是缓冲区（buffer）编程的。Buffer本身就是一块内存，底层实现上，它实际上是个数组。数据的读、写都是通过Buffer来实现的（既能读又能写）。除了数组之外，Buffer还提供了对于数据的结构化访问方式，并且可以追踪到系统的读写过程。

	- 3）Java中的7个原生数据类型都有各自对应的Buffer类型，如IntBuffer,LongBuffer,ByteBuffer等，没有BooleanBuffer类型。

	- 4）Channel指的是可以向其写入数据或从中读取数据的对象，它类似于java.io中的Stream。所有数据的读写都是通过Buffer来进行的，永远不会出现直接channel写入数据的情况，或是直接从Channel读取数据的情况。与stream不同的是，java.io中的一个流只能是OutputStream或是InputStream。由于Channel是双向的，因此它能更好地反映出底层操作系统的真实情况：在linux系统中，底层操作系统的通道就是双向的。

- 34
	- NIO中Buffer中的3个重要的状态属性含义：position，limit，capacity
	- Buffer第一次写到哪儿，limit就指到哪，以后即使反转也不会扩充

- 35
	- 0 <= mark <= position <= limit <= capacity
	- 0拷贝：IO操作的时候，不必将buffer中的内容放到操作系统的内存空间里。直接将分配的内存空间与IO设备打交道。减少内存中转的过程。

- 36 文件通道
	- 通过NIO读取文件涉及3个步骤
		- 1、从FileInputStream获取FileChannel对象
		- 2、创建Buffer
		- 3、将数据从Channel读取到Buffer中

	- 绝对方法与相对方法的含义
		- 1、相对方法： limit值与position值会在操作时被考虑到
		- 2、绝对方法： 完全忽略调limit值和position值。

- 40
	- 传统socker一个连接要起一个线程
	- 一个线程处理N多个客户端

- 42 
	- 事件
## gralde

- 包路径：/Users/chen/.gradle/caches/modules-2/files-2.1

- build.gradle的配置，见netty_lecture

==============================================

## Java秒杀-高性能高并发

- 事务、mybatsi、redis、Thymeleaf页面封装、	Result结果封装

- Jedis是Redis官方推荐的Java连接开发工具

- 避免类的循环依赖

- Fastjson 是一个 Java 库,可以将 Java 对象转换为 JSON 格式,当然它也可以将 JSON 字符串转换为 Java 对象。

- 明文密码在网络上传输，假如数据包被截取到了，明文密码会被别人得到

- 分布式session
	- 用户第一个请求落在第一台服务器，第二个请求落在第二台服务器上，用户的session信息就全部丢失了

	- 登录成功，生成token，写到cookie当中，传递给客户端，客户端在随后的访问中上传这个token，服务端拿到这个token，根据它取到session信息。

- 3
	- 秒杀流程：用户点击商品列表->商品详情->订单详情->秒杀按钮->假如秒杀成功，进入订单
	- vo数据对象，业务层之间的数据传递，可以降低各层之间的耦合。

- 4 压测
	- 并发在1000的时候，我的qps是1000还是500，这种说法才有意义

	-jMeter，先配一个默认值

	- if(cookies == null || cookies.length <= 0)

	- linux top监控服务器内存

	- 打war包。1.pom.xml加个插件 2.改成war 3.进入项目目录，mvn clean package

	- springboot入口

	- 上传.jmx到服务器、./apatch/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl、下载jtl、放到聚合报告里面

	- nohup 忽略输入并把输出追加到"nohup.out"

- 5
	- 从缓存中取、取不到渲染、保存到缓存

	- 缓存前一两页

	- 修改哪个字段，更新哪个字段，所以new一个对象

===========

##乱码恢复

- http://www.mytju.com/classcode/tools/messycoderecover.asp

## Java企业级电商项目架构演进之路Tomcat集群与Redis分布式

=================

#### 从0到上线开发企业级电商项目

- .gitignore

- PO、BO、VO
	- 第一种PO是数据库对象，service层封装成BO，controller层封装成vo，传给前端展示
	- 第二种PO是数据库对象，controller层封装成vo，传给前端展示

- mybatis-gernarate、mybatis-plugin、mybatis-分页

- 拦截/* ，走spring的Filter

- 2
	- 配置源 
		- mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
		- wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
		- yum makecache
	- ftp
		- yum -y install vsftpd
		- useradd ftpuser -d /ftpfile/ -s /sbin/nologin
- 6
	set集合，equal和hash都要重写

- 部署与自动化发布
	- ./deploy.sh

	- 配置configuration导入本地jar包

## 图灵学院JAVA互联网架构企业级实战专题课程

- 2.classloader
	构造器包含静态变量、静态块

## 理财系统springboot

- 重写toString，打印日志可以简单的看到他的内部结构

- 数据库关联注解 @Entity(name = "order_t")

- 看下gradle的配置

- 数据对象，不使用原始内线，不使用默认值

## Java深入微服务原理改造房产销售平台

- spring官网生成spring-boot project，eclipsetoolsuite导入

## 深入剖析SpringBoot源码

- 环境搭建不错

## Netty+Springboot仿微信聊天全栈实战

## 详解Spring Boot编程思想-从技术到规范

## Java攻城狮必备技能-接口自动化测试实战

- 最后两章

## Java持久化规范JPA入门到精通详解

- xml提示，要配XSD文件

===================================

## Socket网络编程

- 4
	- 三次握手的意义：自己说的话，对方能听到；对方说的话，自己能听到

- 6
	- 本机跑服务器，启动java visualVM。另一台启1000个客户端连接服务器。

## 设计模式

- 代理模式

	- Cglib代理不需要接口

- 工厂模式

	- 简单工厂模式也叫静态工厂模式，就是把对象放进工厂里面赋值，再在外面给包装一下
	
	- 工厂方法模式、抽象工厂模式类似

## 深入剖析SpringBoot源码

- Spring Boot 启动原理解析(一) https://www.jianshu.com/p/437d80e43638

- Spring Boot 启动原理解析(二) Tomcat 启动详解 https://juejin.im/post/6844903533397950472



## gupaoVIP

- 2.源码专题
	
	- spinrg boot

		- 版本：spring-boot-1.5.22.RELEASE
		
		- 设计模式 && Sping思想 https://blog.csdn.net/art_code/article/details/90509477

		- 准备：查看sts版本，进入包目录。sts无法下载groovy插件，采用idea。parent报maven错，指向本地项目，没有问题。

		- 起步：ClassPathXmlApplicationContext

	- spring

		- 版本：4.3.30.BUILD-SNAPSHOT

		- 定位、载入、注册

		- BeanDefinition：解析xml，把信息保存到内存中去。

		- Applicationcontext体系：实现servlet

		- refresh()方法保证容器是单例的

		- 定位就是找到recourse

		- spring框架，以do开头的方法，都是具体干活

		- spring单例用map

		- spring创建出来的bean是动态代理出来的，拥有bean类的控制权，可以做切面

		- ConcurrentReferenceHashMap存储bean对象

		- AOP

			- 打个比方，方法是造一辆车，经过流水线的每个环节，都给车装上新的东西

			- 用电脑模拟的车代替真实的车，组装的过程在电脑上实现

	- mybatis

		- 注解、XML两种方式看源码

		- hibernate可以生成表、mybatis不行，目标是轻量级

		- typeHandler用来做映射

		- EnumOrdinalTypeHandler是在干嘛？
		https://my.oschina.net/SEyanlei/blog/188053

		- 插件

		- 分页讲半天讲了什么

		- 联合查询

		- mapper接口、xml，是为了拿到sql

		- 动态代理

		- mybatis-spring集成

- 3.分布式
	
	- 什么是分布式：任务分解、节点通信

	- serialVersionUID保证序列化的对象和反序列化以后的对象是同一个

- 4.性能优化

	- https://man7.org/linux/man-pages/man1/top.1.html

- 5.面试题




## 设计模式

- 继承不好

==============

## oa项目等20

SSH框架、分页

===========

## java大神之路

第一季

第五季 条件查询	StringBuilder用法	test类的路径		方法参数不要超过5个

分页

mysql 

MySQL架构总览->查询执行流程->SQL解析顺序
https://www.cnblogs.com/annsshadow/p/5037667.html

explain分析
https://www.cnblogs.com/clphp/p/5403215.html

================= 大数据 ==================

## hadoop
shuffle就是洗牌

================= ssm教程 ===========

源码
https://github.com/SQX-0330/MyBatis/blob/006cee7796312ef393f08e991534be628815e330/3_mybatis_config/src/main/resources/mybatis-config.xml

mybatis
	
- jar包下可以找到dtd文件

- 有参写了，一定要写无参