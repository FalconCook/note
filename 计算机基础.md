=============== 补码 ========

## 思路
0000 0000 	
8位二进制最大表示为0111 1111，即127。最小0000 0000，即0。
0-1=1111 1111 即-1，最高位符号位。
第一种方法（推荐）：
-1的绝对值1，0000 0001，取反1111 1110。+1，1111 1111
第二种方法：
-1的原码1000 0001，符号位不变，其他位取反，1111 1110。+1：1111 1111

## -6的补码
源码：10000110
符号位不变，其他位取反：11111001
+1：11111010

## 补码11111111表示什么？
-1：11111110
除符号位取反：10000001
结论：-1

问题：经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;

正确答案: B   你的答案: 空 (错误)

128  127

128  -128

128  128

编译错误

例子：
java int 128转为byte，值：
128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。



========== 正则 =========

## 正则
http://tool.oschina.net/uploads/apidocs/jquery/regexp.html
https://www.runoob.com/regexp/regexp-rule.html

## 正则转义
replaceAll("\\.", "/")     //com.cracker->com/cracker
\\会转义成反斜杠，反斜杠本身就是转义符，所有就成了“\.”，在进行转义就是.，所以\\.实际上是“.”。

========== 幂等性 =========

## 一口气说出四种幂等性解决方案
https://juejin.cn/post/6906290538761158670

